#ifndef __ezavi_h__
#define __ezavi_h__

#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * SECTION:ezavi
 * 
 * ezavi attempts to simplify the process of generating AVI movie files.  It
 * supports generating uncompressed 24-bit BGR AVI files.
 */
typedef struct _ezavi ezavi_t;

/**
 * ezavi_params_t:
 *
 * @exact_path_name If you know the exact file name you want to use, provide it here.
 *                 Otherwise, pass NULL here and specify the options to auto-
 *                 generate a path.
 * @path:          directory where the AVI will be create.  NULL specifies
 *                 the current working directory.
 * @file_prefix:   the portion of the filename prior to ".avi"  Do not specify
 *                 the ".avi", as it is automatically appended.  Also, do not
 *                 include a path.
 * @date_in_file:  Set to 1 if the current date should be encoded in the
 *                 filename before @file_prefix.
 * @codec:         currently, "raw" is the only allowed codec.
 * @width:         width of the input image, and resulting AVI video
 * @height:        height of the input image, and resulting AVI video.
 * @src_stride:    number of bytes separating rows of the input images.
 *                 The rowstride of the output AVI is automatically calculated,
 *                 and is not always the same as src_stride.
 * @frame_rate:    frames per second
 * @split_point:   The maximum file size for each segment of generated video.
 *                 Since strictly correct AVI files have a physical limit of 4
 *                 GB, an AVI movie must be split before it reaches 4 GB.
 *                 ezavi automatically switches files after the amount written
 *                 exceeds split_point bytes.  If split_point is set to zero,
 *                 then it defaults to 1 GB.
 *
 *                 generated AVI files are named file_prefix-00.avi, 
 *                 file_prefix-01.avi, etc.
 */
typedef struct _ezavi_params_t {
    char *exact_path_name;
    char *path;
    char *file_prefix;
    int date_in_file;
    char *codec;
    int width;
    int height;
    int src_stride;
    double frame_rate;
    uint32_t split_point;
} ezavi_params_t;

/**
 * ezavi_new:
 *
 * constructor.
 */
ezavi_t * ezavi_new (const ezavi_params_t *params);

/**
 * ezavi_destroy:
 *
 * destructor.  implicitly calls ezavi_finish if necessary
 */
void ezavi_destroy (ezavi_t * self);

/**
 * ezavi_finish:
 *
 * closes an ezavi data structure for writing, but does not free the instance.
 */
void ezavi_finish (ezavi_t * self);

/**
 * ezavi_write_video:
 * @data: the image frame to write to disk.  The image should have dimensions
 *        width x height (specified in ezavi_new) and a rowstride of exactly
 *        width x 3
 *
 * write video frame to disk
 *
 * Returns: 0 on success, -1 on failure (and sets errno)
 */
int ezavi_write_video (ezavi_t *self, const uint8_t *data);

/**
 * ezavi_write_video_bottom_up:
 *
 * write video frame to disk, but assumes that the image is passed in with the
 * lowest rows first, and highest rows last.  This is useful for writing
 * buffers generated by glReadPixels and other OpenGL functions, and can avoid 
 * unnecessary memcpy operations.
 *
 * Returns: 0 on success, -1 on failure (and sets errno)
 */
int ezavi_write_video_bottom_up (ezavi_t * self, const uint8_t *data);

// returns the current video time, in seconds.
double ezavi_get_video_pts (ezavi_t * self);

// returns the total number of frames written so far
unsigned int ezavi_get_frame_count (ezavi_t * self);

char * ezavi_get_filename (ezavi_t * self);

#ifdef __cplusplus
}
#endif

#endif
